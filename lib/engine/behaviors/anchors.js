/**
 * アンカーに関するビヘイバを納めたファイル。
 */

//==========================================================================================================
/**
 * 指定されたターゲットを位置合わせの基準とし、宿主のポジションを変更するビヘイバ(アンカー)の基底クラス。
 *
 * 飽くまで位置を調節するだけのもの。宿主のサイズを変更することはない。
 * 対になる両辺に設定を施してサイズにも作用するアンカーとなると、NGUIのように四辺を統合管理するものが必要になると思う。
 */
class AnchorBehavior extends Behavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   位置合わせの基準となる実行素子。宿主の親とする場合はnullを指定する。
     * @param   ターゲットのどこに合わせるか。具体的には派生クラスが決める。
     * @param   そこからずらして調節したい場合に、ずらす量。具体的には派生クラスが決める。
     */
    constructor(target, pivot, offset) {
        super();

        // 基底では、pivot省略時は中央、オフセット省略時はオフセットなしとして補正される。
        this.target = target;
        this.pivot = (pivot == undefined) ? 0.5 : pivot;
        this.offset = (offset == undefined) ? 0 : offset;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * アタッチ／デタッチされたときに...
     */
    attached(host) {
        super.attached(host);

        // アタッチされたタイミングで、ターゲットが指定されていなかったら宿主の親とする。
        if(host  &&  !this.target)
            this.target = host.parent;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * フレームごとのアフターフェーズで呼ばれる。
     */
    stay(scene) {

        // ターゲットのボディビヘイバーを取得。
        var body = this.target.behaviors['body'];
        if(!body)
            return;

        // ターゲットの矩形を取得して、宿主の親の座標系を基準に直す。なぜ親かというと宿主のpositionは親の座標系のものだから。
        var pile = body.getRect();
        pile = this.host.parent.takeCoord(pile, this.target).normalize();   // parentがnullってことは…ないだろ。階層に入ってない状態でここに来るとは思えないし、シーンにアンカー付けることもないはず。

        // ターゲットが階層に入っていないというのはあり得る…
        if(!pile)
            return;

        // 前回位置と変わっていないなら処理はない。
        if( this.prev  &&  this.prev.equals(pile) )
            return;

        // 位置合わせして、前回位置として覚える。
        this.anchor(pile);
        this.prev = pile;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * ターゲットの相対位置が変更されたら呼ばれる。
     */
    anchor(pile) {

        // ピボットを加味して位置するべき座標を取得。オフセットはまだ適用しない。
        var point = pile.getPoint(this.pivot);

        // 得られた座標をもとに派生クラスで位置を調整させる。
        this.adjust(point);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 指定された座標にオフセットを適用して宿主の座標を変更する。
     *
     * @param   基準とするべき座標。
     */
    adjust(point) {

        throw "実装してください";
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * デフォルトキー名を定義する。
     */
    get defaultKeyName() {
        return "anchor";
    }
}


//==========================================================================================================
/**
 * 指定されたターゲットのボディ領域を元に、宿主のポジションを変更するビヘイバ。
 */
class PositionAnchor extends AnchorBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   位置合わせの基準となる実行素子。宿主の親とする場合はnullを指定する。
     * @param   ターゲットのどこに合わせるかのPoint。左上なら(0, 0)、右下なら(1, 1)。省略時は中心になる。
     * @param   そこからずらして調節したい場合は、ずらす量をPointで指定する。
     */
    constructor(target, pivot, offset) {
        super(target, pivot, offset);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * adjust() を実装。
     * 指定された座標にオフセットを適用して宿主の座標を変更する。
     */
    adjust(point) {

        // オフセットを適用してからポジションとする。
        this.host.position.put( point.add(this.offset) );
    }
}


//==========================================================================================================
/**
 * 指定されたターゲットのボディ領域を元に、宿主の辺の位置を調整するビヘイバ。
 * PositionAnchor はpositionに直接作用しているが、このアンカーは辺を合わせるためにpositionを変更しようとする。
 * アンカーを張りたい一辺に対して一つセットする。対になる両辺にこのアンカーをセットした場合の挙動は未定義。
 */
class EdgeAnchor extends AnchorBehavior {

    //------------------------------------------------------------------------------------------------------
    /**
     * @param   宿主のどの辺を合わせるか。"left", "top", "right", "bottom" のいずれか。
     * @param   ターゲットとなる実行素子。宿主の親とする場合はnullを指定する。
     * @param   ターゲットのどこに合わせるか。左or上なら 0.0、右or下なら 1.0。省略時は中心になる。
     *          キーワード "left", "top", "right", "bottom", "center" で指定することも可能。
     * @param   そこからずらして調節したい場合は、ずらす量を指定する。
     */
    constructor(edge, target, pivot, offset) {

        if(typeof pivot == "string") {
            switch(pivot) {
                case "left": case "top":        pivot = 0.0;    break;
                case "center":                  pivot = 0.5;    break;
                case "right": case "bottom":    pivot = 1.0;    break;
            }
        }

        super(target, pivot, offset);

        this.edge = edge;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * adjust() を実装。
     * 指定された座標にオフセットを適用して宿主の座標を変更する。
     */
    adjust(point) {

        // 調整する座標を取得。
        var axis = (this.edge == "left"  ||  this.edge == "right") ? "x" : "y";

        // オフセットを適用。
        var align = point[axis] + this.offset;

        // 自身の矩形を得る。
        var body = this.host.behaviors["body"].getRect();

        // 指定の辺を合わせる。
        this.host.position[axis] = align - body[this.edge];
    }
}
