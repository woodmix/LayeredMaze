/**
 * ビヘイバーの基底と、ビヘイバー用のトレイトを収めたファイル。
 */

//==========================================================================================================
/**
 * ビヘイバーの基底。
 * ビヘイバーとは実行素子の振る舞いを抜き出したもの。ビヘイバを切り替えたり追加したりすることで、
 * 実行素子はその性質を選択したり変化したりすることができる。
 */
class Behavior {

    //------------------------------------------------------------------------------------------------------
    constructor() {

        // 宿主の実行素子。
        this.host = undefined;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 実行素子にアタッチ・デタッチされたときに呼ばれる。
     *
     * @param   宿主となる実行素子。デタッチされた場合はnull。
     */
    attached(host) {

        this.host = host;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * フレームごとのアップデートフェーズで呼ばれる。
     * needReset() を適用しておくと初回だけはbehaveの代わりにresetを呼ぶようにも設定できる。
     *
     * @param   描画先キャンバスとタイミングを管理しているシーンオブジェクト。
     */
    behave(scene) {
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * フレームごとのアフターフェーズで呼ばれる。
     *
     * @param   描画先キャンバスとタイミングを管理しているシーンオブジェクト。
     */
    stay(scene) {
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * needReset() を呼んだ後、最初にbehave()が呼ばれる代わりに呼ばれる。
     * この場合behave()は呼ばれないので注意。必要な場合は手動で呼ぶ必要がある。
     *
     * @param   描画先キャンバスとタイミングを管理しているシーンオブジェクト。
     */
    reset(scene) {
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 次のbehaveの呼び出しをresetに変更する。
     */
    needReset() {

        this.behave = this.resetCaller;
    }

    /**
     * resetをコールするために一時的に behave() を乗っ取る関数。
     */
    resetCaller(scene) {

        delete this.behave;
        this.reset(scene);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * 宿主から自身を削除する。
     *
     * @param   通常の削除ではなく即座に削除したい場合は true を指定する。
     */
    bye(now = false) {

        if(!this.host)  return;

        // 自身の名前を探す。
        var name = this.host.behaviors.index(this);

        // 引数の指定に応じたメソッドで削除。
        this.host.setBehaviorNow(null, name);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * ビヘイバーのデフォルトキー名を表す。キー名を指定せずに素子に追加したときに使われる。
     */
    get defaultKeyName() {
        return undefined;
    }
}


//==========================================================================================================
/**
 * 「目標」という概念があるビヘイバーに取り込まれるトレイト。
 * このトレイトを取り込んだビヘイバーは目標に到達したときに finish() を呼ぶようにしておけば、次のプロパティを実装することが出来る。
 *      ・onfinish      目標に到達したら呼び出される宿主のメソッド名かコールバック関数。
 *      ・autoremove    到達時に自身を削除するなら true を指定する。
 */
class FinishTrait {

    //------------------------------------------------------------------------------------------------------
    /**
     * 「目標」に到達したときの処理を行う。
     */
    finish() {

        // onfinish 呼び出し。第一引数はこのビヘイバー。
        if(this.onfinish) {
            if(typeof this.onfinish == "string")  this.host[this.onfinish](this);
            else                                  this.onfinish(this);
        }

        // 自動削除することになっているなら自身を宿主から削除する。
        if(this.autoremove)  this.bye();
    }
}


//==========================================================================================================
/**
 * 設定された動作時間長さを元に、経過時間から進捗率を求めて何らかの処理を行うようなビヘイバーに取り込まれるトレイト。FinishTraitも継承する。
 * behave() をこちらで処理しているので、継承クラスは tictoc() をオーバーライドして処理する。
 */
class ProgressionTrait extends FinishTrait {

    //------------------------------------------------------------------------------------------------------
    /**
     * 初期化を行う。
     *
     * @param   動作時間長さ(ms)
     */
    initializeTimer(duration) {

        this.duration = duration;
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。実行素子にアタッチ・デタッチされたときに呼ばれる。
     */
    attached(host) {

        // アタッチされて最初のフレーム時、初期化処理を行う。
        if(host)  this.needReset();

        // 基底の処理。
        this.super(ProgressionTrait.prototype.attached, host);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。needReset() を呼んだ後、最初にbehave()が呼ばれる代わりに呼ばれる。
     */
    reset(scene) {

        // 経過した時間を初期化。
        this.passed = 0;

        // 基底の処理。
        this.super(ProgressionTrait.prototype.reset, scene);

        // 最初のフレームでは進捗率 0.0 でtictoc()が呼ばれるようにする。
        this.tictoc(0.0, scene);
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド。毎フレーム実行される。
     */
    behave(scene) {

        var burnable = (this.passed < this.duration);

        // 経過時間を更新して、進捗率を得る。
        this.passed += scene.delta;
        var progress = this.passed / this.duration;

        // 自動削除が有効な場合に進捗率が 1.0 に到達した場合は、最後の進捗率を 1.0 に揃える。
        if(this.autoremove  &&  progress >= 1.0)
            progress = 1.0;

        // 派生クラスの処理。
        this.tictoc(progress, scene);

        // 目標到達処理を行う。
        if(burnable  &&  1.0 <= progress)
            this.finish();
    }

    //------------------------------------------------------------------------------------------------------
    /**
     * オーバーライド用。behave()の代わりに毎フレーム実行される。
     *
     * @param   設定された動作時間長さに対する時間経過率。
     * @param   描画先キャンバスとタイミングを管理しているシーンオブジェクト。
     */
    tictoc(progress, scene) {
    }
}
